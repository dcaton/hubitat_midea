/*

*/

metadata
{
    definition(name: "raw socket testing", namespace: "tomw", author: "tomw", importUrl: "")
    {
        command "openSocket"
        command "closeSocket"
        
        command "_authenticate"
        
        command "trace"
    }
}

preferences
{
    section
    {
        input name: "ipAddress", type: "text", title: "IP address", required: true
        input name: "port", type: "number", title: "port", required: true, defaultValue: 6444
        input name: "id", type: "text", title: "id", required: true
        input name: "token", type: "text", title: "token", required: true
        input name: "key", type: "text", title: "key", required: true
        input name: "logEnable", type: "bool", title: "Enable debug logging", defaultValue: true
    }
}

def logDebug(msg) 
{
    if (logEnable)
    {
        log.debug(msg)
    }
}

def trace()
{
    def intKey = '434a209a5ce141c3b726de067835d7f0'
    byte[] intData = (0..127).collect{it}

    /*
    
    logDebug("starting 2 byte test")
    0.upto(0xffff)
    {
        if(it != bytesToInt(intToBytes(it, 2, "little"), "little"))
        {
            logDebug("error: {it}")
        }
    }
    logDebug("done with 2 byte test")
    
    logDebug("starting 2 byte test")
    0.upto(0xffff)
    {
        if(it != bytesToInt(intToBytes(it, 2, "big"), "big"))
        {
            logDebug("error: {it}")
        }
    }
    logDebug("done with 2 byte test")

    /*
    logDebug("starting 8 byte test")
    for(int i = 0; i <= 0xffffffffffffffff; i + 0xF00F0FF0)
    {
        if(i != bytesToInt(intToBytes(i, 8, "little"), "little"))
        {
            logDebug("error: {i}")
        }
    }
    logDebug("done with 8 byte test")
*/    
    
    def enc = aes_cbc(intData, "enc", intKey)
    def dec = aes_cbc(enc, "dec", intKey)    
    logDebug("testing intData == dec: ${intData == dec}")

    def tokenB = token.getBytes() ?: 
        'd765eba84382ab05da02c036d080b5bac25eb7653d3f99a0c352d6a1ef526aaeb32fd4eddc734802327d8e5b63dc7b3539ef8d3b483fa69fe13b2a5a3a744a54'.getBytes()
    
    def enc8370 = encode_8370(tokenB, MSGTYPE_HANDSHAKE_REQUEST)
    logDebug(enc8370.collect{it & 0xFF})
    def dec8370 = decode_8370(enc8370)
    logDebug("tokenB == dec8370 (non-enc): = ${tokenB == dec8370}")
    
    enc8370 = encode_8370(tokenB, MSGTYPE_ENCRYPTED_REQUEST)
    dec8370 = decode_8370(enc8370)    
    logDebug("tokenB == dec8370 (enc): = ${tokenB == dec8370}")

    /*
    intData = (0..63).collect{it}
    intKey = 'ed39553af1748a24f88e8c8db815dc5a'
    MessageDigest digest = MessageDigest.getInstance("SHA-256")
    def sign = digest.digest(intData)    
    def eBytes = aes_cbc(intData, "enc", intKey)
    
    tcp_key(appendByteArr(eBytes, sign), intKey)
    */
    
}


def socketStatus(String message)
{
    logDebug("socketStatus: ${message}")
}

def parse(String message)
{
    logDebug("parse: ${message}")
    
    def rdB = hubitat.helper.HexUtils.hexStringToByteArray(message)
    logDebug("parse: ${rdB}")
    
    if(rdB.size() >= 72)
    {
        def response = subBytes(rdB, 8, 64)
        logDebug("tcp_key: ${tcp_key(response, key)}")
    }                 
}

def openSocket()
{
    try
    {
        interfaces.rawSocket.connect(ipAddress, port.toInteger(), byteInterface: true)
    }
    catch (Exception e)
    {
        logDebug("error: ${e.message}")
    }
}

def closeSocket()
{
    try
    {
        interfaces.rawSocket.close()
    }
    catch (Exception e)
    {
        // swallow errors
    }
}

def _writeBytes(byte[] bytes)
{
    logDebug("writeBytes: ${bytes.collect{it & 0xFF}}")
    
    
    def wrStr = hubitat.helper.HexUtils.byteArrayToHexString(bytes)
    logDebug("writeBytes: ${wrStr}")
    
    interfaces.rawSocket.sendMessage(wrStr)  
}

def _authenticate()
{
    def request = encode_8370(token.getBytes(), MSGTYPE_HANDSHAKE_REQUEST)
    _writeBytes(request)
}

import groovy.transform.Field
@Field MSGTYPE_HANDSHAKE_REQUEST = 0x0
@Field MSGTYPE_HANDSHAKE_RESPONSE = 0x1
@Field MSGTYPE_ENCRYPTED_RESPONSE = 0x3
@Field MSGTYPE_ENCRYPTED_REQUEST = 0x6
@Field MSGTYPE_TRANSPARENT = 0xf

import java.security.MessageDigest

def encode_8370(data, msgtype)
{
    byte[] header = [i8Tou8(0x83), i8Tou8(0x70)]
    
    def size = data.size()
    def padding = 0
    
    if(msgtype in [MSGTYPE_ENCRYPTED_RESPONSE, MSGTYPE_ENCRYPTED_REQUEST])
    {
        if((size + 2) % 16 != 0)
        {
            padding = 16 - ((size + 2) & 0xf)
            size += (padding + 32)
            
            byte[] pBytes = new byte[padding]
            new Random().nextBytes(pBytes)
            data = appendByteArr(data, pBytes)
        }
    }
    
    header = appendByteArr(header, intToBytes(size, 2, "big"))
    header = appendByteArr(header, [i8Tou8(0x20), i8Tou8(padding << 4 | msgtype)])
    
    def request_count = state.request_count ?: 0
    data = appendByteArr(intToBytes(request_count, 2, "big"), data)
    state.request_count = request_count + 1
    
    if(msgtype in [MSGTYPE_ENCRYPTED_RESPONSE, MSGTYPE_ENCRYPTED_REQUEST])
    {
        MessageDigest digest = MessageDigest.getInstance("SHA-256")
        def sign = digest.digest(appendByteArr(header, data))
        
        // if tcp_key isn't available, just use a random key
        data = aes_cbc(data, "enc", state.tcp_key ?: '434a209a5ce141c3b726de067835d7f0')
        
        data = appendByteArr(data, sign)
    }
    
    return appendByteArr(header, data)
}

def decode_8370(data)
{    
    def header = subBytes(data, 0, 6)
    data = subBytes(data, 6, data.size() - 6)

    if(i8Tou8(bytesToInt([header[0]], "big")) != 0x83 || i8Tou8(bytesToInt([header[1]], "big")) != 0x70)
    {
        logDebug("not an 8370 message")
        return []
    }
    
    if(i8Tou8(bytesToInt([header[4]], "big")) != 0x20)
    {
        logDebug("missing byte 4")
        return []
    }
    
    def padding = i8Tou8(bytesToInt([header[5]], "big")) >> 4
    def msgtype = i8Tou8(bytesToInt([header[5]], "big")) & 0xf
    
    def size = i16Tou16(bytesToInt(subBytes(header, 2, 2), "big"))
    
    if(data.size() < (size + 2))
    {
        // request_count was not in size, so count 2 extra bytes here
        logDebug("data.size() = ${data.size()}, size + 2 = ${size + 2}")
        return []
    }
    
    if(msgtype in [MSGTYPE_ENCRYPTED_RESPONSE, MSGTYPE_ENCRYPTED_REQUEST])
    {
        sign = subBytes(data, data.size() - 32, 32)
        data = subBytes(data, 0, data.size() - 32)
        
        // if tcp_key isn't available, just use a random key
        data = aes_cbc(data, "dec", '434a209a5ce141c3b726de067835d7f0')
        
        MessageDigest digest = MessageDigest.getInstance("SHA-256")
        def check = digest.digest(appendByteArr(header, data))
        
        if(check != sign)
        {
            logDebug("sign does not match")
            return []
        }
        
        if(padding)
        {
            data = subBytes(data, 0, data.size() - padding)
        }
    }    

    state.response_count = bytesToInt(subBytes(data, 0, 2), "big")
    data = subBytes(data, 2, data.size() - 2)
    
    return data
}

import javax.crypto.spec.SecretKeySpec
import javax.crypto.spec.IvParameterSpec
import javax.crypto.Cipher

def aes_cbc(data, op = "enc", key = key)
{
    // thanks: https://community.hubitat.com/t/groovy-aes-encryption-driver/31556
    
    def cipher = Cipher.getInstance("AES/CBC/PKCS5Padding", "SunJCE")
    
    // note: we already have the key from midea-smart    
    byte[] encodedKey = key.getBytes()
    SecretKeySpec aKey = new SecretKeySpec(encodedKey, 0, encodedKey.length, "AES")
    
    //self.iv = b'\0' * 16
    def IVKey = '\0' * 16
    IvParameterSpec iv = new IvParameterSpec(IVKey.getBytes("UTF-8"))
    
    cipher.init(op == "enc" ? Cipher.ENCRYPT_MODE : Cipher.DECRYPT_MODE, aKey, iv)
    
    return cipher.doFinal(data)
}

def tcp_key(response, key = key)
{
    if(response == 'ERROR'.getBytes())
    {
        logDebug("authentication failed")
        return null
    }
    
    if(response.size() != 64)
    {
        logDebug("unexpected data length")
        return null
    }
        
    def payload = subBytes(response, 0, 32)
    def sign = subBytes(response, 32, 32)
    
    def plain = aes_cbc(payload, "dec", key)
    
    MessageDigest digest = MessageDigest.getInstance("SHA-256")
    if(sign != digest.digest(plain))
    {
        logDebug("sign does not match")
        return null
    }
    
    logDebug("tcp_key plain = ${plain.collect{it & 0xFF}}")
    
    def tcp_key = plain ^ key.getBytes()
    state.tcp_key = tcp_key
    
    state.request_count = 0
    state.response_count = 0
    
    return tcp_key
}

def request_status_command()
{
    def req = 
    [
        // 0 header
        0xaa,
        // 1 command lenght: N+10
        0x20,
        // 2 device type (0xAC for air conditioner)
        0xac,
        // 3 Frame SYN CheckSum
        0x00,
        // 4-5 Reserved
        0x00, 0x00,
        // 6 Message ID
        0x00,
        // 7 Frame Protocol Version
        0x00,
        // 8 Device Protocol Version
        0x00,
        // 9 Message Type: request is 0x03; setting is 0x02
        0x03,
        
        // Byte0 - Data request/response type: 0x41 - check status; 0x40 - Set up
        0x41,
        // Byte1
        0x81,
        // Byte2 - operational_mode
        0x00,
        // Byte3
        0xff,
        // Byte4
        0x03,
        // Byte5
        0xff,
        // Byte6
        0x00,
        // Byte7 - Room Temperature Request: 0x02 - indoor_temperature, 0x03 - outdoor_temperature
        // when set, this is swing_mode
        0x02,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        // Message ID
        0x00
    ]
    
    req[-1] = (new Date().getTime() / 1000).toInteger()
}

def packet_builder(device_id, command)
{
    // Init the packet with the header data
    def packet =
        [
            // 2 bytes - StaicHeader
            0x5a, 0x5a,
            // 2 bytes - mMessageType
            0x01, 0x11,
            // 2 bytes - PacketLenght
            0x00, 0x00,
            // 2 bytes
            0x20, 0x00,
            // 4 bytes - MessageId
            0x00, 0x00, 0x00, 0x00,
            // 8 bytes - Date&Time
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            // 6 bytes - mDeviceID
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            // 12 bytes
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        ]
    
    //self.packet[12:20] = self.packet_time()
    //'%Y%m%d%H%M%S%f'
    def dateBytes = hubitat.helper.HexUtils.hexStringToByteArray(new Date().format('yyyyMMddHHmmssSSSS'))
    packet = replaceSubArr(packet, subBytes(dateBytes, 0, 8), 12)
    
    //self.packet[20:28] = device_id.to_bytes(8, 'little')
    packet = replaceSubArr(packet, intToBytes(device_id, 8, "little"), 20)        
}

def appendByteArr(a, b)
{
    byte[] c = new byte[a.size() + b.size()]
    
    a.eachWithIndex()
    {
        it, i ->
        c[i] = it
    }
    
    def aSz = a.size()
    
    b.eachWithIndex()
    {
        it, i ->
        c[i + aSz] = it
    }
    
    return c
}

def replaceSubArr(orig_arr, new_arr, start)
{
    def tmp_arr = orig_arr.collect()
    new_arr.eachWithIndex
    {
        it, i ->
        tmp_arr[i + start] = it
    }
    
    return tmp_arr
}

private subBytes(arr, start, length)
{
    byte[] sub = new byte[length]
    
    for(int i = 0; i < length; i++)
    {
        sub[i] = arr[i + start]
    }
    
    return sub
}

def swapEndianness(input)
{
    def output = new BigInteger(input).intValue()
    output = Integer.reverseBytes(output)
    
    return output.toBigInteger().toByteArray()
}

def intToBytes(input, width, endian = "little")
{
    def output = new BigInteger(input).toByteArray()
    
    byte[] pad
    
    if(output.size() < width)
    {
        def padding = width - output.size()
        pad = [0] * padding
        output = appendByteArr(pad, output)        
    }
    
    switch(endian)
    {
        case "little":
            output = swapEndianness(output)    
    }
    
    return output.collect{it & 0xFF}
}

def bytesToInt(input, endian = "little")
{
    def output = subBytes(input, 0, input.size())
    
    output = (endian == "little") ? swapEndianness(output) : output
    output.collect{it & 0xFF}

    return be = new BigInteger(output).intValue() 
}

def i8Tou8(input)
{
    return input & 0xFF
}

def i16Tou16(input)
{
    return input & 0xFFFF
}
