/*

*/

metadata
{
    definition(name: "raw socket testing", namespace: "tomw", author: "tomw", importUrl: "")
    {
        command "openSocket"
        command "closeSocket"
        
        command "_authenticate"
        command "_refresh"
        
        command "trace"
    }
}

preferences
{
    section
    {
        input name: "ipAddress", type: "text", title: "IP address", required: true
        input name: "port", type: "number", title: "port", required: true, defaultValue: 6444
        input name: "id", type: "text", title: "id", required: true
        input name: "token", type: "text", title: "token", required: true
        input name: "key", type: "text", title: "key", required: true
        input name: "logEnable", type: "bool", title: "Enable debug logging", defaultValue: true
    }
}

def logDebug(msg) 
{
    if (logEnable)
    {
        log.debug(msg)
    }
}

def trace()
{
    def intKey = '434a209a5ce141c3b726de067835d7f0'
    byte[] intData = (0..127).collect{it}

    /*
    
    logDebug("starting 2 byte test")
    0.upto(0xffff)
    {
        if(it != bytesToInt(intToBytes(it, 2, "little"), "little"))
        {
            logDebug("error: {it}")
        }
    }
    logDebug("done with 2 byte test")
    
    logDebug("starting 2 byte test")
    0.upto(0xffff)
    {
        if(it != bytesToInt(intToBytes(it, 2, "big"), "big"))
        {
            logDebug("error: {it}")
        }
    }
    logDebug("done with 2 byte test")

    /*
    logDebug("starting 8 byte test")
    for(int i = 0; i <= 0xffffffffffffffff; i + 0xF00F0FF0)
    {
        if(i != bytesToInt(intToBytes(i, 8, "little"), "little"))
        {
            logDebug("error: {i}")
        }
    }
    logDebug("done with 8 byte test")
    */

    /*
    def enc = aes_cbc(intData, "enc", intKey)
    def dec = aes_cbc(enc, "dec", intKey)    
    logDebug("testing intData == dec: ${intData == dec}")
    */
    
    /*
    def enc2 = aes_ecb(intData, "enc")
    def dec2 = aes_ecb(enc2, "dec")
    logDebug("testing intData == dec2: ${intData == dec2}")
    */
    
    /*
    def tokenB = hubitat.helper.HexUtils.hexStringToByteArray(token ?: 'd765eba84382ab05da02c036d080b5bac25eb7653d3f99a0c352d6a1ef526aaeb32fd4eddc734802327d8e5b63dc7b3539ef8d3b483fa69fe13b2a5a3a744a54')
    
    def enc8370 = encode_8370(tokenB, MSGTYPE_HANDSHAKE_REQUEST)
    logDebug(enc8370.collect{it & 0xFF})
    def dec8370 = decode_8370(enc8370)
    logDebug("tokenB == dec8370 (non-enc): = ${tokenB == dec8370}")
    
    enc8370 = encode_8370(tokenB, MSGTYPE_ENCRYPTED_REQUEST)
    dec8370 = decode_8370(enc8370)    
    logDebug("tokenB == dec8370 (enc): = ${tokenB == dec8370}")
    */


    /*
    intData = (0..63).collect{it}
    intKey = 'ed39553af1748a24f88e8c8db815dc5a'
    MessageDigest digest = MessageDigest.getInstance("SHA-256")
    def sign = digest.digest(intData)    
    def eBytes = aes_cbc(intData, "enc", intKey)
    
    tcp_key(appendByteArr(eBytes, sign), intKey)
    */
    
    /*
    byte[] resp = [-125, 112, 0, 64, 32, 1, -119, 72, -70, 107, -61, 12, -63, 1, -90, 19, 107, -90, -56, -112, 22, -127, 5, 119, 66, 97, 112, 39, -80, -41, -52, -70, -28, -94, -118, 5, -85, -128, -119, -40, 47, -107, 55, -55, -11, -60, 36, -19, -64, -32, -10, 94, 114, 107, -7, -63, -41, 110, -41, 64, 111, 41, -118, -107, 121, 64, 57, 77, 71, -64, 121, 96]
    logDebug(getMsgType(resp))
    logDebug(tcp_key(resp, key))
    */
    
    //byte[] req = request_status_command()    
    //logDebug(hubitat.helper.HexUtils.byteArrayToHexString(packet_builder(id, req)))
    
    parse('837000402001894897218CF1C79F143381578B67AC6420413CC363855D1E16A3E992337E609F8D72388862B10FA11851651EB2D502C73530AFCCAE6818F8BF7C6340C3426D5176AD')
    parse('83700040200189484552524F52')
    
    /*
    def req = '8370008E2066D531645D3E0EB420E989EB5847B8A445F98AC9F81DEA7D1ED6FD81E736FCF9785A8059D1EEF3052EDEB5AD5E55CA5E073931E8E304CD697E0639208A92CF468CA0F2DDA25E012FCFCF57CE159B4EF151AAA117BE2EFD0A9A7048EA65FC0F51F800510DC5DC1C2679A4E75DBB88C220351AB928F0499D2D0A4ADC725D6FDF3E340396A86FBBF422BCC5787BACB75C456E'
    logDebug(decode_8370(hubitat.helper.HexUtils.hexStringToByteArray(req)))
    */
}

def socketStatus(String message)
{
    logDebug("socketStatus: ${message}")
}

def parse(String message)
{
    logDebug("parse: ${message}")    
    def rdB = hubitat.helper.HexUtils.hexStringToByteArray(message)
    logDebug("parse: ${rdB}")
    
    if(rdB.size() < 13)
    {
        logDebug("response too short")
        return
    }
    
    if(rdB.size() == 13)
    {
        // just catch 'ERROR'
        rdB = subBytes(rdB, 8, 5)
        logDebug("rdB = ${new String(rdB)}")
        return
    }
    
    switch(getMsgType(rdB))
    {
        case MSGTYPE_HANDSHAKE_RESPONSE:
            logDebug("tcp_key: ${tcp_key(rdB, key)}")
            break
        
        case MSGTYPE_ENCRYPTED_RESPONSE:
            logDebug("parse enc resp = ${rdB}")
            logDebug("decode_8370 = ${decode_8370(rdB)}")
            break
    }
}

def openSocket()
{
    try
    {
        interfaces.rawSocket.connect(ipAddress, port.toInteger(), byteInterface: true)
    }
    catch (Exception e)
    {
        logDebug("error: ${e.message}")
    }
}

def closeSocket()
{
    try
    {
        interfaces.rawSocket.close()
    }
    catch (Exception e)
    {
        // swallow errors
    }
}

def _writeBytes(byte[] bytes)
{
    logDebug("writeBytes: ${bytes.collect{it & 0xFF}}")    
    
    def wrStr = hubitat.helper.HexUtils.byteArrayToHexString(bytes)
    logDebug("writeBytes: ${wrStr}")
    
    interfaces.rawSocket.sendMessage(wrStr)  
}

def _authenticate()
{
    def tokenBytes = hubitat.helper.HexUtils.hexStringToByteArray(token)
    
    logDebug("tokenBytes = ${tokenBytes}")
    request = encode_8370(tokenBytes, MSGTYPE_HANDSHAKE_REQUEST)
    _writeBytes(request)
}

def _refresh()
{
    def packet = packet_builder(id, request_status_command())
    logDebug("_refresh packet = ${packet}")
    
    appliance_transparent_send_8370(packet, MSGTYPE_ENCRYPTED_REQUEST)    
}

import groovy.transform.Field
@Field MSGTYPE_HANDSHAKE_REQUEST = 0x0
@Field MSGTYPE_HANDSHAKE_RESPONSE = 0x1
@Field MSGTYPE_ENCRYPTED_RESPONSE = 0x3
@Field MSGTYPE_ENCRYPTED_REQUEST = 0x6
@Field MSGTYPE_TRANSPARENT = 0xf

import java.security.MessageDigest

def getMsgType(header)
{
    if(i8Tou8(bytesToInt([header[0]], "big")) != 0x83 || i8Tou8(bytesToInt([header[1]], "big")) != 0x70)
    {
        logDebug("not an 8370 message")
        return -1
    }
    
    if(header.size() < 6)
    {
        logDebug("header too short")
        return -1
    }
    
    def msgtype = i8Tou8(bytesToInt([header[5]], "big")) & 0xf
}

def encode_8370(data, msgtype)
{
    byte[] header = [i8Tou8(0x83), i8Tou8(0x70)]
    
    def size = data.size()
    def padding = 0
    
    if(msgtype in [MSGTYPE_ENCRYPTED_RESPONSE, MSGTYPE_ENCRYPTED_REQUEST])
    {
        if((size + 2) % 16 != 0)
        {
            padding = 16 - ((size + 2) & 0xf)
            size += (padding + 32)
            
            byte[] pBytes = new byte[padding]
            new Random().nextBytes(pBytes)
            data = appendByteArr(data, pBytes)
        }
    }
    
    header = appendByteArr(header, intToBytes(size, 2, "big"))
    header = appendByteArr(header, [i8Tou8(0x20), i8Tou8(padding << 4 | msgtype)])
    
    def request_count = state.request_count ?: 0
    data = appendByteArr(intToBytes(request_count, 2, "big"), data)
    state.request_count = request_count + 1
    
    if(msgtype in [MSGTYPE_ENCRYPTED_RESPONSE, MSGTYPE_ENCRYPTED_REQUEST])
    {
        MessageDigest digest = MessageDigest.getInstance("SHA-256")
        def sign = digest.digest(appendByteArr(header, data))
        
        // if tcp_key isn't available, just use a random key
        data = aes_cbc(data, "enc", state.tcp_key ?: '4D67055D53288313335D65FB2CBA3DDB04001F8AF6880CBDB5BC45DA67EC8A35')
        
        data = appendByteArr(data, sign)
    }
    
    return appendByteArr(header, data)
}

def decode_8370(data)
{    
    def header = subBytes(data, 0, 6)
    data = subBytes(data, 6, data.size() - 6)

    if(i8Tou8(bytesToInt([header[0]], "big")) != 0x83 || i8Tou8(bytesToInt([header[1]], "big")) != 0x70)
    {
        logDebug("not an 8370 message")
        return []
    }
    
    if(i8Tou8(bytesToInt([header[4]], "big")) != 0x20)
    {
        logDebug("missing byte 4")
        return []
    }
    
    def padding = i8Tou8(bytesToInt([header[5]], "big")) >> 4
    def msgtype = getMsgType(header)
    
    def size = i16Tou16(bytesToInt(subBytes(header, 2, 2), "big"))
    
    if(data.size() < (size + 2))
    {
        // request_count was not in size, so count 2 extra bytes here
        logDebug("data.size() = ${data.size()}, size + 2 = ${size + 2}")
        return []
    }
    
    if(msgtype in [MSGTYPE_ENCRYPTED_RESPONSE, MSGTYPE_ENCRYPTED_REQUEST])
    {
        sign = subBytes(data, data.size() - 32, 32)
        data = subBytes(data, 0, data.size() - 32)
        
        // if tcp_key isn't available, just use a random key
        data = aes_cbc(data, "dec", state.tcp_key ?: '4D67055D53288313335D65FB2CBA3DDB04001F8AF6880CBDB5BC45DA67EC8A35')
        
        MessageDigest digest = MessageDigest.getInstance("SHA-256")
        def check = digest.digest(appendByteArr(header, data))
        
        if(check != sign)
        {
            logDebug("sign does not match")
            return []
        }
        
        if(padding)
        {
            data = subBytes(data, 0, data.size() - padding)
        }
    }    

    state.response_count = i16Tou16(bytesToInt(subBytes(data, 0, 2), "big"))
    data = subBytes(data, 2, data.size() - 2)
    
    return data
}

import javax.crypto.spec.SecretKeySpec
import javax.crypto.spec.IvParameterSpec
import javax.crypto.Cipher

@Field signKey = 'xhdiwjnchekd4d512chdjx5d8e4c394D2D7S'.getBytes()

def aes_cbc(data, op = "enc", key = key)
{
    // thanks: https://community.hubitat.com/t/groovy-aes-encryption-driver/31556
    
    def cipher = Cipher.getInstance("AES/CBC/NoPadding", "SunJCE")
    
    // note: we already have the key from midea-smart    
    byte[] keyBytes = hubitat.helper.HexUtils.hexStringToByteArray(key)
    SecretKeySpec aKey = new SecretKeySpec(keyBytes, 0, keyBytes.length, "AES")
    
    //self.iv = b'\0' * 16
    def IVKey = '\0' * 16
    IvParameterSpec iv = new IvParameterSpec(IVKey.getBytes("UTF-8"))
    
    cipher.init(op == "enc" ? Cipher.ENCRYPT_MODE : Cipher.DECRYPT_MODE, aKey, iv)
    
    return cipher.doFinal(data)
}

def aes_ecb(data, op = "enc")
{    
    def encKey = md5(signKey)
    SecretKeySpec aKey = new SecretKeySpec(encKey, 0, encKey.length, "AES")
    
    def cipher = Cipher.getInstance("AES/ECB/PKCS5Padding", "SunJCE")
    cipher.init(op == "enc" ? Cipher.ENCRYPT_MODE : Cipher.DECRYPT_MODE, aKey)
    
    return cipher.doFinal(data)
}

def md5(data)
{
    MessageDigest digest = MessageDigest.getInstance("MD5")
    byte[] md5sum = digest.digest()
    
    return md5sum
}

def tcp_key(response, key = key)
{
    if(subBytes(response, 8, 5) == 'ERROR'.getBytes())
    {
        logDebug("authentication failed")
        return null
    }
    
    if(response.size() != 72)
    {
        logDebug("unexpected data length")
        return null
    }

    response = subBytes(response, 8, 64)
        
    def payload = subBytes(response, 0, 32)
    def sign = subBytes(response, 32, 32)
    
    def plain = aes_cbc(payload, "dec", key)
    
    MessageDigest digest = MessageDigest.getInstance("SHA-256")
    if(sign != digest.digest(plain))
    {
        logDebug("sign does not match")
        return null
    }    
    
    byte[] keyBytes = hubitat.helper.HexUtils.hexStringToByteArray(key)
    
    if(plain.size() != keyBytes.size())
    {
        logDebug("size mismatch")
        return null
    }
    
    (0..(plain.size() - 1)).each
    {
        // tcp_key = strxor(plain, key)
        plain[it] = plain[it] ^ keyBytes[it]
    }

    def tcp_key = hubitat.helper.HexUtils.byteArrayToHexString(plain)
    state.tcp_key = tcp_key
    
    state.request_count = 0
    state.response_count = 0
    
    return tcp_key
}

def appliance_transparent_send_8370(data, msgtype=MSGTYPE_ENCRYPTED_REQUEST)
{
    if(!state.tcp_key)
    {
        logDebug("missing tcp_key.  need to _authenticate")
        return
    }
    
    def sData = subBytes(data, 0, data.size())
    sData = encode_8370(sData, msgtype)
    _writeBytes(sData)
}

def request_status_command()
{
    byte[] req = 
    [
        // 0 header
        0xaa,
        // 1 command lenght: N+10
        0x20,
        // 2 device type (0xAC for air conditioner)
        0xac,
        // 3 Frame SYN CheckSum
        0x00,
        // 4-5 Reserved
        0x00, 0x00,
        // 6 Message ID
        0x00,
        // 7 Frame Protocol Version
        0x00,
        // 8 Device Protocol Version
        0x00,
        // 9 Message Type: request is 0x03; setting is 0x02
        0x03,
        
        // Byte0 - Data request/response type: 0x41 - check status; 0x40 - Set up
        0x41,
        // Byte1
        0x81,
        // Byte2 - operational_mode
        0x00,
        // Byte3
        0xff,
        // Byte4
        0x03,
        // Byte5
        0xff,
        // Byte6
        0x00,
        // Byte7 - Room Temperature Request: 0x02 - indoor_temperature, 0x03 - outdoor_temperature
        // when set, this is swing_mode
        0x02,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        // Message ID
        (state.request_count ?: 1) & 0xFF
    ]
    
    //self.data[-1] = datetime.datetime.now().second
    //byte[] secs = 0//intToBytes((new Date().getTime() / 1000).toInteger(), 1, "little")
    //req = appendByteArr(req, secs)
    
    return req
}

def packet_builder(device_id, command)
{
    // Init the packet with the header data
    def packet =
        [
            // 2 bytes - StaicHeader
            0x5a, 0x5a,
            // 2 bytes - mMessageType
            0x01, 0x11,
            // 2 bytes - PacketLenght
            0x00, 0x00,
            // 2 bytes
            0x20, 0x00,
            // 4 bytes - MessageId
            0x00, 0x00, 0x00, 0x00,
            // 8 bytes - Date&Time
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            // 6 bytes - mDeviceID
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            // 12 bytes
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        ]
    
    //self.packet[12:20] = self.packet_time()
    //'%Y%m%d%H%M%S%f'
    def dateBytes = hubitat.helper.HexUtils.hexStringToByteArray(new Date().format('yyyyMMddHHmmssSSSS'))
    packet = replaceSubArr(packet, subBytes(dateBytes, 0, 8), 12)
    
    //self.packet[20:28] = device_id.to_bytes(8, 'little')
    packet = replaceSubArr(packet, intToBytes(device_id, 8, "little"), 20)

    // base_command.finalize()
    // Add the CRC8
    def crc = crc8(subBytes(command, 10, command.size() - 10))
    command = appendByteArr(command, [i8Tou8(crc)])
    logDebug(command.size())
    // Set the length of the command data
    // self.data[0x01] = len(self.data)

    // Add checksum
    def checksum = checksum(subBytes(command, 1, command.size() - 1))
    command = appendByteArr(command, [i8Tou8(checksum)])
    logDebug(command.size())
    
    // packet_builder.finalize()
    def encCmd = aes_ecb(command, "enc")
    // Append the command data(48 bytes) to the packet
    packet = appendByteArr(packet, subBytes(encCmd, 0, 48))
    // PacketLength
    packet = replaceSubArr(packet, intToBytes(packet.size() + 16, 2, "little"), 4)
    // Append a basic checksum data(16 bytes) to the packet
    packet = appendByteArr(packet, md5(appendByteArr(packet, signKey)))
    
    return packet
}

def appendByteArr(a, b)
{
    byte[] c = new byte[a.size() + b.size()]
    
    a.eachWithIndex()
    {
        it, i ->
        c[i] = it
    }
    
    def aSz = a.size()
    
    b.eachWithIndex()
    {
        it, i ->
        c[i + aSz] = it
    }
    
    return c
}

def replaceSubArr(orig_arr, new_arr, start)
{
    def tmp_arr = orig_arr.collect()
    new_arr.eachWithIndex
    {
        it, i ->
        tmp_arr[i + start] = it
    }
    
    return tmp_arr
}

private subBytes(arr, start, length)
{
    byte[] sub = new byte[length]
    
    for(int i = 0; i < length; i++)
    {
        sub[i] = arr[i + start]
    }
    
    return sub
}

def swapEndianness(input)
{
    def output = new BigInteger(input).intValue()
    output = Integer.reverseBytes(output)
    
    return output.toBigInteger().toByteArray()
}

def intToBytes(input, width, endian = "little")
{
    def output = new BigInteger(input).toByteArray()
    
    byte[] pad
    
    if(output.size() < width)
    {
        def padding = width - output.size()
        pad = [0] * padding
        output = appendByteArr(pad, output)        
    }
    
    switch(endian)
    {
        case "little":
            output = swapEndianness(output)    
    }
    
    return output.collect{it & 0xFF}
}

def bytesToInt(input, endian = "little")
{
    def output = subBytes(input, 0, input.size())
    
    output = (endian == "little") ? swapEndianness(output) : output
    output.collect{it & 0xFF}

    return be = new BigInteger(output).intValue() 
}

def i8Tou8(input)
{
    return input & 0xFF
}

def i16Tou16(input)
{
    return input & 0xFFFF
}

@Field crc8_854_table =
    [
    0x00, 0x5E, 0xBC, 0xE2, 0x61, 0x3F, 0xDD, 0x83,
    0xC2, 0x9C, 0x7E, 0x20, 0xA3, 0xFD, 0x1F, 0x41,
    0x9D, 0xC3, 0x21, 0x7F, 0xFC, 0xA2, 0x40, 0x1E,
    0x5F, 0x01, 0xE3, 0xBD, 0x3E, 0x60, 0x82, 0xDC,
    0x23, 0x7D, 0x9F, 0xC1, 0x42, 0x1C, 0xFE, 0xA0,
    0xE1, 0xBF, 0x5D, 0x03, 0x80, 0xDE, 0x3C, 0x62,
    0xBE, 0xE0, 0x02, 0x5C, 0xDF, 0x81, 0x63, 0x3D,
    0x7C, 0x22, 0xC0, 0x9E, 0x1D, 0x43, 0xA1, 0xFF,
    0x46, 0x18, 0xFA, 0xA4, 0x27, 0x79, 0x9B, 0xC5,
    0x84, 0xDA, 0x38, 0x66, 0xE5, 0xBB, 0x59, 0x07,
    0xDB, 0x85, 0x67, 0x39, 0xBA, 0xE4, 0x06, 0x58,
    0x19, 0x47, 0xA5, 0xFB, 0x78, 0x26, 0xC4, 0x9A,
    0x65, 0x3B, 0xD9, 0x87, 0x04, 0x5A, 0xB8, 0xE6,
    0xA7, 0xF9, 0x1B, 0x45, 0xC6, 0x98, 0x7A, 0x24,
    0xF8, 0xA6, 0x44, 0x1A, 0x99, 0xC7, 0x25, 0x7B,
    0x3A, 0x64, 0x86, 0xD8, 0x5B, 0x05, 0xE7, 0xB9,
    0x8C, 0xD2, 0x30, 0x6E, 0xED, 0xB3, 0x51, 0x0F,
    0x4E, 0x10, 0xF2, 0xAC, 0x2F, 0x71, 0x93, 0xCD,
    0x11, 0x4F, 0xAD, 0xF3, 0x70, 0x2E, 0xCC, 0x92,
    0xD3, 0x8D, 0x6F, 0x31, 0xB2, 0xEC, 0x0E, 0x50,
    0xAF, 0xF1, 0x13, 0x4D, 0xCE, 0x90, 0x72, 0x2C,
    0x6D, 0x33, 0xD1, 0x8F, 0x0C, 0x52, 0xB0, 0xEE,
    0x32, 0x6C, 0x8E, 0xD0, 0x53, 0x0D, 0xEF, 0xB1,
    0xF0, 0xAE, 0x4C, 0x12, 0x91, 0xCF, 0x2D, 0x73,
    0xCA, 0x94, 0x76, 0x28, 0xAB, 0xF5, 0x17, 0x49,
    0x08, 0x56, 0xB4, 0xEA, 0x69, 0x37, 0xD5, 0x8B,
    0x57, 0x09, 0xEB, 0xB5, 0x36, 0x68, 0x8A, 0xD4,
    0x95, 0xCB, 0x29, 0x77, 0xF4, 0xAA, 0x48, 0x16,
    0xE9, 0xB7, 0x55, 0x0B, 0x88, 0xD6, 0x34, 0x6A,
    0x2B, 0x75, 0x97, 0xC9, 0x4A, 0x14, 0xF6, 0xA8,
    0x74, 0x2A, 0xC8, 0x96, 0x15, 0x4B, 0xA9, 0xF7,
    0xB6, 0xE8, 0x0A, 0x54, 0xD7, 0x89, 0x6B, 0x35
    ]

int crc8(value)
{
    // thanks: http://www.java2s.com/example/java-utility-method/crc-calculate/crc8-string-value-6f7a7.html
    
    int crc = 0
    for (int i = 0; i < value.size(); i++)
    {
        crc = crc8_854_table[value[i] ^ (crc & 0xFF)]
    }
    
    return crc
}

def checksum(data)
{
    def sum = 0
    data.each{ sum = (sum += (it & 0xFF)) & 0xFF }
    return (~ sum + 1) & 0xFF
}
